{"filter":false,"title":"separate_chaining.rb","tooltip":"/separate_chaining/separate_chaining.rb","undoManager":{"mark":12,"position":12,"stack":[[{"start":{"row":0,"column":0},"end":{"row":97,"column":4},"action":"insert","lines":["require_relative 'linked_list'","","","class SeparateChaining","  attr_reader :max_load_factor","","  def initialize(size)","    @max_load_factor = 0.7","    @items = Array.new(size)","    @count =  0 ","  end","","  def []=(key, value)","    newnode = Node.new(key, value)","    i = index(key,size)","    if @items[i] == nil ","      @items[i] = LinkedList.new","      @items[i].add_to_front(newnode)","      @count += 1","    else","      current = @items[i].head","      until current == nil || current.key == key","        current = current.next","      end","      if current == nil","        @items[i].add_to_front(newnode)","        @count += 1","      elsif current.key == key && current.value != value","        current.value = value ","      end","    end","    if load_factor > @max_load_factor","      resize","    end","  end","","  def [](key)","","    i = index(key, size)","    if @items[i]","      h = @items[i].head","      while h != nil ","        if h.key == key","          return h.value","        else","          h = h.next ","        end","      end","    end","  end","","  # Returns a unique, deterministically reproducible index into an array","  # We are hashing based on strings, let's use the ascii value of each string as","  # a starting point.","  def index(key, size)","    key.sum % size","  end","","  # Calculate the current load factor","  def load_factor","    @count.fdiv(size)","  end","","  # Simple method to return the number of items in the hash","  def size","    @items.length","  end","","  # Resize the hash","  def resize","    arr = Array.new(size * 2)","    iter = 0..@items.length","    iter.each do |ele|","      if @items[ele] != nil ","        n = @items[ele].head","        until n == nil ","          newi = n.key.sum % arr.length","          arr[newi] = LinkedList.new","          arr[newi].add_to_front(n)","          n = n.next","        end","      @items[ele] = nil ","      end","    end","    @items = arr","  end","end","",""," def print_hash ","    iter  = (0..size)","    iter.each do |ele|","      if @items[ele] != nil ","        puts \"index is #{ele} , key is #{@items[ele].key} , value of the key is #{@items[ele].value}\"","      end","      puts \"load factor is #{load_factor}\"","    end"," end"],"id":1}],[{"start":{"row":0,"column":0},"end":{"row":49,"column":5},"action":"remove","lines":["require_relative 'linked_list'","","","class SeparateChaining","  attr_reader :max_load_factor","","  def initialize(size)","    @max_load_factor = 0.7","    @items = Array.new(size)","    @count =  0 ","  end","","  def []=(key, value)","    newnode = Node.new(key, value)","    i = index(key,size)","    if @items[i] == nil ","      @items[i] = LinkedList.new","      @items[i].add_to_front(newnode)","      @count += 1","    else","      current = @items[i].head","      until current == nil || current.key == key","        current = current.next","      end","      if current == nil","        @items[i].add_to_front(newnode)","        @count += 1","      elsif current.key == key && current.value != value","        current.value = value ","      end","    end","    if load_factor > @max_load_factor","      resize","    end","  end","","  def [](key)","","    i = index(key, size)","    if @items[i]","      h = @items[i].head","      while h != nil ","        if h.key == key","          return h.value","        else","          h = h.next ","        end","      end","    end","  end"],"id":3},{"start":{"row":0,"column":0},"end":{"row":81,"column":3},"action":"insert","lines":["require_relative 'node'","require_relative 'linked_list'","","class SeparateChaining","  attr_reader :max_load_factor","","  def initialize(size)","    @max_load_factor = 0.7","    @lists = Array.new(size)","  end","","  def []=(key, value)","    node = Node.new(key, value)","    i = index(key, self.size)","    if @lists[i].nil?","      list = LinkedList.new","      list.add_to_tail(node)","      @lists[i] = list ","    elsif @lists[i].size < 5","      @lists[i].add_to_tail(node)","    else","      resize","      self[key] = value","    end","    if self.load_factor > @max_load_factor","      resize","    end","  end","","  def [](key)","    i = index(key, self.size)","    if !@lists[i].nil?","      node = @lists[i].find_node(key)","      if !node.value.nil?","        return node.value","      end","    end","  end","","  # Returns a unique, deterministically reproducible index into an array","  # We are hashing based on strings, let's use the ascii value of each string as","  # a starting point.","  def index(key, size)","    key.sum % size","  end","","  # Calculate the current load factor","  def load_factor","    x = 0.0","    for i in 0..self.size-1","      if !@lists[i].nil?","        x += @lists[i].size ","      end","    end","    x / self.size ","  end","","  # Simple method to return the number of items in the hash","  def size","    @lists.length","  end","","  # Resize the hash","  def resize","    old_lists = @lists.compact","    @lists = Array.new(self.size * 2)","    old_lists.each do |list|","      while list.size > 0","        node = list.remove_front","        self[node.key] = node.value ","      end","    end","  end","","  def print","    for i in 0..self.size-1","      if !@lists[i].nil?","        @lists[i].print(i)","      end","    end","  end","end"]}],[{"start":{"row":0,"column":0},"end":{"row":129,"column":4},"action":"remove","lines":["require_relative 'node'","require_relative 'linked_list'","","class SeparateChaining","  attr_reader :max_load_factor","","  def initialize(size)","    @max_load_factor = 0.7","    @lists = Array.new(size)","  end","","  def []=(key, value)","    node = Node.new(key, value)","    i = index(key, self.size)","    if @lists[i].nil?","      list = LinkedList.new","      list.add_to_tail(node)","      @lists[i] = list ","    elsif @lists[i].size < 5","      @lists[i].add_to_tail(node)","    else","      resize","      self[key] = value","    end","    if self.load_factor > @max_load_factor","      resize","    end","  end","","  def [](key)","    i = index(key, self.size)","    if !@lists[i].nil?","      node = @lists[i].find_node(key)","      if !node.value.nil?","        return node.value","      end","    end","  end","","  # Returns a unique, deterministically reproducible index into an array","  # We are hashing based on strings, let's use the ascii value of each string as","  # a starting point.","  def index(key, size)","    key.sum % size","  end","","  # Calculate the current load factor","  def load_factor","    x = 0.0","    for i in 0..self.size-1","      if !@lists[i].nil?","        x += @lists[i].size ","      end","    end","    x / self.size ","  end","","  # Simple method to return the number of items in the hash","  def size","    @lists.length","  end","","  # Resize the hash","  def resize","    old_lists = @lists.compact","    @lists = Array.new(self.size * 2)","    old_lists.each do |list|","      while list.size > 0","        node = list.remove_front","        self[node.key] = node.value ","      end","    end","  end","","  def print","    for i in 0..self.size-1","      if !@lists[i].nil?","        @lists[i].print(i)","      end","    end","  end","end","","  # Returns a unique, deterministically reproducible index into an array","  # We are hashing based on strings, let's use the ascii value of each string as","  # a starting point.","  def index(key, size)","    key.sum % size","  end","","  # Calculate the current load factor","  def load_factor","    @count.fdiv(size)","  end","","  # Simple method to return the number of items in the hash","  def size","    @items.length","  end","","  # Resize the hash","  def resize","    arr = Array.new(size * 2)","    iter = 0..@items.length","    iter.each do |ele|","      if @items[ele] != nil ","        n = @items[ele].head","        until n == nil ","          newi = n.key.sum % arr.length","          arr[newi] = LinkedList.new","          arr[newi].add_to_front(n)","          n = n.next","        end","      @items[ele] = nil ","      end","    end","    @items = arr","  end","end","",""," def print_hash ","    iter  = (0..size)","    iter.each do |ele|","      if @items[ele] != nil ","        puts \"index is #{ele} , key is #{@items[ele].key} , value of the key is #{@items[ele].value}\"","      end","      puts \"load factor is #{load_factor}\"","    end"," end"],"id":4},{"start":{"row":0,"column":0},"end":{"row":81,"column":3},"action":"insert","lines":["require_relative 'node'","require_relative 'linked_list'","","class SeparateChaining","  attr_reader :max_load_factor","","  def initialize(size)","    @max_load_factor = 0.7","    @lists = Array.new(size)","  end","","  def []=(key, value)","    node = Node.new(key, value)","    i = index(key, self.size)","    if @lists[i].nil?","      list = LinkedList.new","      list.add_to_tail(node)","      @lists[i] = list ","    elsif @lists[i].size < 5","      @lists[i].add_to_tail(node)","    else","      resize","      self[key] = value","    end","    if self.load_factor > @max_load_factor","      resize","    end","  end","","  def [](key)","    i = index(key, self.size)","    if !@lists[i].nil?","      node = @lists[i].find_node(key)","      if !node.value.nil?","        return node.value","      end","    end","  end","","  # Returns a unique, deterministically reproducible index into an array","  # We are hashing based on strings, let's use the ascii value of each string as","  # a starting point.","  def index(key, size)","    key.sum % size","  end","","  # Calculate the current load factor","  def load_factor","    x = 0.0","    for i in 0..self.size-1","      if !@lists[i].nil?","        x += @lists[i].size ","      end","    end","    x / self.size ","  end","","  # Simple method to return the number of items in the hash","  def size","    @lists.length","  end","","  # Resize the hash","  def resize","    old_lists = @lists.compact","    @lists = Array.new(self.size * 2)","    old_lists.each do |list|","      while list.size > 0","        node = list.remove_front","        self[node.key] = node.value ","      end","    end","  end","","  def print","    for i in 0..self.size-1","      if !@lists[i].nil?","        @lists[i].print(i)","      end","    end","  end","end"]}],[{"start":{"row":12,"column":4},"end":{"row":12,"column":8},"action":"remove","lines":["node"],"id":5},{"start":{"row":12,"column":4},"end":{"row":12,"column":5},"action":"insert","lines":["n"]},{"start":{"row":12,"column":5},"end":{"row":12,"column":6},"action":"insert","lines":["e"]},{"start":{"row":12,"column":6},"end":{"row":12,"column":7},"action":"insert","lines":["w"]},{"start":{"row":12,"column":7},"end":{"row":12,"column":8},"action":"insert","lines":["_"]},{"start":{"row":12,"column":8},"end":{"row":12,"column":9},"action":"insert","lines":["n"]}],[{"start":{"row":16,"column":23},"end":{"row":16,"column":27},"action":"remove","lines":["node"],"id":6},{"start":{"row":16,"column":23},"end":{"row":16,"column":28},"action":"insert","lines":["new_n"]}],[{"start":{"row":19,"column":28},"end":{"row":19,"column":32},"action":"remove","lines":["node"],"id":7},{"start":{"row":19,"column":28},"end":{"row":19,"column":33},"action":"insert","lines":["new_n"]}],[{"start":{"row":64,"column":12},"end":{"row":64,"column":13},"action":"remove","lines":["s"],"id":10},{"start":{"row":64,"column":11},"end":{"row":64,"column":12},"action":"remove","lines":["t"]},{"start":{"row":64,"column":10},"end":{"row":64,"column":11},"action":"remove","lines":["s"]},{"start":{"row":64,"column":9},"end":{"row":64,"column":10},"action":"remove","lines":["i"]}],[{"start":{"row":66,"column":12},"end":{"row":66,"column":13},"action":"remove","lines":["s"],"id":11},{"start":{"row":66,"column":11},"end":{"row":66,"column":12},"action":"remove","lines":["t"]},{"start":{"row":66,"column":10},"end":{"row":66,"column":11},"action":"remove","lines":["s"]},{"start":{"row":66,"column":9},"end":{"row":66,"column":10},"action":"remove","lines":["i"]}],[{"start":{"row":68,"column":8},"end":{"row":68,"column":12},"action":"remove","lines":["node"],"id":12},{"start":{"row":68,"column":8},"end":{"row":68,"column":13},"action":"insert","lines":["new_n"]}],[{"start":{"row":69,"column":13},"end":{"row":69,"column":17},"action":"remove","lines":["node"],"id":13},{"start":{"row":69,"column":13},"end":{"row":69,"column":18},"action":"insert","lines":["new_n"]}],[{"start":{"row":69,"column":26},"end":{"row":69,"column":30},"action":"remove","lines":["node"],"id":14},{"start":{"row":69,"column":26},"end":{"row":69,"column":31},"action":"insert","lines":["new_n"]}],[{"start":{"row":8,"column":4},"end":{"row":8,"column":10},"action":"remove","lines":["@lists"],"id":15},{"start":{"row":8,"column":4},"end":{"row":8,"column":10},"action":"insert","lines":["@items"]},{"start":{"row":14,"column":7},"end":{"row":14,"column":13},"action":"remove","lines":["@lists"]},{"start":{"row":14,"column":7},"end":{"row":14,"column":13},"action":"insert","lines":["@items"]},{"start":{"row":17,"column":6},"end":{"row":17,"column":12},"action":"remove","lines":["@lists"]},{"start":{"row":17,"column":6},"end":{"row":17,"column":12},"action":"insert","lines":["@items"]},{"start":{"row":18,"column":10},"end":{"row":18,"column":16},"action":"remove","lines":["@lists"]},{"start":{"row":18,"column":10},"end":{"row":18,"column":16},"action":"insert","lines":["@items"]},{"start":{"row":19,"column":6},"end":{"row":19,"column":12},"action":"remove","lines":["@lists"]},{"start":{"row":19,"column":6},"end":{"row":19,"column":12},"action":"insert","lines":["@items"]},{"start":{"row":31,"column":8},"end":{"row":31,"column":14},"action":"remove","lines":["@lists"]},{"start":{"row":31,"column":8},"end":{"row":31,"column":14},"action":"insert","lines":["@items"]},{"start":{"row":32,"column":13},"end":{"row":32,"column":19},"action":"remove","lines":["@lists"]},{"start":{"row":32,"column":13},"end":{"row":32,"column":19},"action":"insert","lines":["@items"]},{"start":{"row":50,"column":10},"end":{"row":50,"column":16},"action":"remove","lines":["@lists"]},{"start":{"row":50,"column":10},"end":{"row":50,"column":16},"action":"insert","lines":["@items"]},{"start":{"row":51,"column":13},"end":{"row":51,"column":19},"action":"remove","lines":["@lists"]},{"start":{"row":51,"column":13},"end":{"row":51,"column":19},"action":"insert","lines":["@items"]},{"start":{"row":59,"column":4},"end":{"row":59,"column":10},"action":"remove","lines":["@lists"]},{"start":{"row":59,"column":4},"end":{"row":59,"column":10},"action":"insert","lines":["@items"]},{"start":{"row":64,"column":12},"end":{"row":64,"column":18},"action":"remove","lines":["@lists"]},{"start":{"row":64,"column":12},"end":{"row":64,"column":18},"action":"insert","lines":["@items"]},{"start":{"row":65,"column":4},"end":{"row":65,"column":10},"action":"remove","lines":["@lists"]},{"start":{"row":65,"column":4},"end":{"row":65,"column":10},"action":"insert","lines":["@items"]},{"start":{"row":76,"column":10},"end":{"row":76,"column":16},"action":"remove","lines":["@lists"]},{"start":{"row":76,"column":10},"end":{"row":76,"column":16},"action":"insert","lines":["@items"]},{"start":{"row":77,"column":8},"end":{"row":77,"column":14},"action":"remove","lines":["@lists"]},{"start":{"row":77,"column":8},"end":{"row":77,"column":14},"action":"insert","lines":["@items"]}],[{"start":{"row":74,"column":0},"end":{"row":80,"column":5},"action":"remove","lines":["  def print","    for i in 0..self.size-1","      if !@items[i].nil?","        @items[i].print(i)","      end","    end","  end"],"id":17},{"start":{"row":74,"column":0},"end":{"row":81,"column":5},"action":"insert","lines":["  def print_hash","    (0...size()).each do |i|","      if @items[i] != nil","        puts \"index: #{i}, #{@items[i].key}: #{@items[i].value}\"","      end","    end","    puts \"load factor: #{load_factor()}\"","  end"]}]]},"ace":{"folds":[],"scrolltop":926.5,"scrollleft":0,"selection":{"start":{"row":82,"column":3},"end":{"row":82,"column":3},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":65,"state":"start","mode":"ace/mode/ruby"}},"timestamp":1575847100442,"hash":"7ecd958f9a1f026dd889be6d738d361eaff86dc4"}